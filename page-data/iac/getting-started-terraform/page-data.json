{"componentChunkName":"component---src-pages-iac-getting-started-terraform-index-mdx","path":"/iac/getting-started-terraform/","result":{"pageContext":{"frontmatter":{"title":"Getting Started with Terraform","description":"Instructions to setup your environment to use Terraform for IBM Cloud","keywords":"terraform,ibm cloud,setup,provider"},"relativePagePath":"/iac/getting-started-terraform/index.mdx","titleType":"page","MdxNode":{"id":"3185d262-af9f-55e4-9612-325d4905e24a","children":[],"parent":"c5f029c2-4715-5bc0-b1a1-9d7b366a4c4d","internal":{"content":"---\ntitle: Getting Started with Terraform\ndescription: Instructions to setup your environment to use Terraform for IBM Cloud\nkeywords: 'terraform,ibm cloud,setup,provider'\n---\n\n<!--\n\nThe pattern to document the resources is like follow:\n- Introduce the resource with an example\n- List all or the most important input parameters\n- If will be used, list the most important output parameters\n- Provide instructions to get the value of the input parameters, either using `ibmcloud`, API or the Web console.\n- If needed, instructions to execute the code either with Terraform or Schematics\n\n-->\n\n<PageDescription>\n\nLearn the basics of Infrastructure as Code with Terraform on IBM Cloud\n\n</PageDescription>\n\nAfter you have configured and verified Terraform and the IBM Cloud provider, this section will go through a step-by-step example of creating a resource on IBM Cloud using the provider. It covers how to create a virtual server from scratch. To do this, there is example terraform code to create a vpc and subnet, add a virtual server to the vpc, configure an access list and expose the virtual server on the Internet, and then access it over ssh. If you are an experienced Terraform user, you may skim through this section and simply note the resource types and parameters used in each step.\n\n<AnchorLinks small>\n  <AnchorLink>Deploy a single instance</AnchorLink>\n  <AnchorLink>“Hello World” from IBM Cloud</AnchorLink>\n  <AnchorLink>Terraform State</AnchorLink>\n  <AnchorLink>Exposing the service to the world in a secure manner</AnchorLink>\n  <AnchorLink>Deploy a configurable server</AnchorLink>\n  <AnchorLink>SSH Access</AnchorLink>\n  <AnchorLink>Final Terraform code</AnchorLink>\n  <AnchorLink>Clean up</AnchorLink>\n</AnchorLinks>\n\n## Deploy a single instance\n\nThe first step to use Terraform with IBM Cloud is to configure the provider. Lets start creating a directory to store the \"Hello World\" project.\n\n```bash\nmkdir hello_world_terraform_ibm\ncd hello_world_terraform_ibm\n```\n\nRemember to export in the terminal or console the variable `IC_API_KEY` with the IBM Cloud API key as shown in the <GatsbyLink to=\"/iac/setup-environment#configure-access-to-ibm-cloud\">Environment Setup</GatsbyLink>.\n\nThe Terraform code can be done with JSON format or using **HashiCorp Configuration Language** (HCL). During this pattern guide we'll use only HCL and we will call it HCL or Terraform Code.\n\nThe Terraform code can be done with JSON format or using **HashiCorp Configuration Language** (HCL). During this pattern guide we'll use only HCL and we will call it HCL or Terraform Code.\n\nCreate the file `main.tf` with the `provider` block.\n\n```hcl\nprovider \"ibm\" {\n  generation         = 2\n  region             = \"us-south\"\n}\n```\n\nWe will be working with VPC Infrastructure Gen 2, the provider accepts the following common input parameters:\n\n| Input parameter | Description |\n|---|---|\n| `generation` | the generation of IBM Cloud VPC Infrastructure, in this case it'll be `2` |\n| `region` | the region where you want to create the VPC resources, examples: `us-south` or `us-east` |\n| `ibmcloud_api_key` | the IBM Cloud API key. However we recommend to enter this parameter with the environment variable `IC_API_KEY` |\n\nTo find all the available regions with IBM Cloud CLI you can use the `is` sub-command (for more information on installing this plugin refer to [Setup Environment](/iac/setup-environment)):\n\n```bash\nibmcloud is regions\n```\n\nNow execute the terraform sub-commands `init` and `plan`:\n\n```bash\nterraform init\nterraform plan\n```\n\nThe `init` sub-command downloads all the terraform components needed to execute or apply the terraform code, in this simple example it does not need to download any, the only component we need is the IBM Cloud provider and it is already installed. You'll see there is a new `.terraform` directory, this is where terraform will store all the required components for your terraform project.\n\nThe output of `plan` shows the resources that will be created, updated and deleted, in this case terraform won't do anything.\n\nTo create a VM or instance we use the resource `ibm_is_instance` but in order to have an instance you first need the networking resources to build the instance on top of it.\n\nOn IBM Cloud there is no VPC created by default, you will need to create your VPC using the `ibm_is_vpc` resource. Then we'll need a subnet on that VPC, the subnets are created with the resource `ibm_is_subnet`.\n\n<InlineNotification>\n\n###### Resources naming convention\n\nIn case you haven't noticed yet, the IBM Cloud resources begin with `ibm_`, the `is_` stands for Internet Service.\n\n</InlineNotification>\n\nThe Terraform code to create the VPC and the Subnet is as follows:\n\n```hcl\nresource \"ibm_is_vpc\" \"iac_test_vpc\" {\n  name = \"terraform-test-vpc\"\n  tags = [ \"iac-terraform-test\" ]\n}\n\nresource \"ibm_is_subnet\" \"iac_test_subnet\" {\n  name            = \"terraform-test-subnet\"\n  vpc             = ibm_is_vpc.iac_test_vpc.id\n  zone            = \"us-south-1\"\n  tags = [ \"iac-terraform-test\" ]\n}\n```\n\nThe most important input parameters to create the VPC and the Subnet are listed below.\n\nFor the `ibm_is_vpc` resource:\n\n| Input parameter | Description |\n|---|---|\n| `name` | to name the VPC |\n| `resource_group` | the ID of the resource group for the VPC, the default resource group is `default` |\n| `tags` | tags to associate with your VPC, they will help you to find the VPC more easily. Separate multiple tags with a comma |\n\nFor the `ibm_is_subnet` resource:\n\n| Input parameter | Description |\n|---|---|\n| `name` | to name the Subnet |\n| `vpc` | the ID of the VPC, use the resource name with `.id` |\n| `zone` | the subnet zone name |\n| `resource_group` | the ID of the resource group for the Subnet |\n| `tags` | tags to associate with your Subnet, they will help you to find it more easily. Separate multiple tags with a comma |\n\nThe IBM Cloud virtual server instance is created with the resource `ibm_is_instance`, a basic terraform code to create an instance would be like so:\n\n```hcl\nresource \"ibm_is_instance\" \"iac_test_instance\" {\n  name    = \"terraform-test-instance\"\n  image   = \"r006-14140f94-fcc4-11e9-96e7-a72723715315\"\n  profile = \"cx2-2x4\"\n\n  primary_network_interface {\n    name   = \"eth1\"\n    subnet = ibm_is_subnet.iac_test_subnet.id\n  }\n\n  vpc  = ibm_is_vpc.iac_test_vpc.id\n  zone = \"us-south-1\"\n  keys = []\n\n  tags = [ \"iac-terraform-test\" ]\n}\n```\n\nSome of the most important input parameters are:\n\n| Input parameter | Description |\n|---|---|\n| `name` | to name the new instance |\n| `image` | the ID of the virtual server image to use for the instance |\n| `profile` | name of the profile to use for your instance |\n| `vpc`  | the ID of the VPC where you want to create the instance |\n| `zone` | name of the VPC zone to create the instance |\n| `keys` | a comma separated list of SSH keys that you want to add to your instance |\n| `primary_network_interface.subnet` | the ID of the subnet. Only one primary network interface can be specified for an instance |\n| `tags` | a list of tags to add to your instance. Tags can help you find your instance |\n| `user_data` | user data to transfer to the instance |\n\n<InlineNotification>\n\n###### VPC Networking and Virtual Servers\n\nCheck the documentation to know more about [Networking for VPC](https://cloud.ibm.com/docs/vpc?topic=vpc-about-networking-for-vpc) and [Virtual Servers](https://cloud.ibm.com/docs/vpc?topic=vpc-about-advanced-virtual-servers).\n\n</InlineNotification>\n\nTo list all the available images and profiles we will use `ibmcloud is`, specify the **Gen 2** platform before running the command:\n\n```bash\nibmcloud is target --gen 2        # this is a one time execution only, unless you swap to gen 1\nibmcloud is instance-profiles\nibmcloud is images\n```\n\nThat's a lot of images, to narrow our search let's filter the output to get the available images for `Ubuntu 18.4` (`LTS Bionic`) and for `amd64` architecture using regular *nix commands or with `jq`, if you have `jq` installed ([how to install jq](https://github.com/stedolan/jq/wiki/Installation)):\n\n```bash\nibmcloud is images | grep available | grep ubuntu-18 | grep amd64 | cut -f1 -d\" \"\n\nibmcloud is images --json | jq -r '.[] | select(.status==\"available\" and .operating_system.name==\"ubuntu-18-04-amd64\").id'\n```\n\nRepeating for the instance profiles searching just the `amd64` architecture with the minimum CPU and Memory to get the lowest cost.\n\n```bash\nibmcloud is instance-profiles | grep amd64 | sort -k4 -k5 -n | head -1 | cut -f1 -d\" \"\n\nibmcloud is instance-profiles --json | jq -r 'map(select(.vcpu_architecture.value==\"amd64\")) | sort_by(.memory.value)[0].name'\n```\n\nNotice that in the terraform code there are no `keys` this is because the instance will be used only to start a web service, and we are not going to ssh to the instance at this time.\n\nYou can use `user_data` to run common configuration tasks when your instance starts. For example, you can specify cloud-init directives or shell scripts for Linux images. You will see an example of using the `user_data` parameter in the next session.\n\nAdd to the `main.tf` file the terraform code for the vpc, subnet and instance. Now, if you execute `terraform plan` it shows the resources that will be created, updated and deleted. In this case terraform will create 3 resources: the VPC, the subnet and the instance.\n\nEverything is ready now to get that instance in the cloud, just execute the terraform `apply` sub-command and wait about 10 to 60 seconds.\n\n```bash\nterraform apply\n```\n\n<InlineNotification>\n\n###### Can I make it non-interactive?\n\nTerraform will ask for confirmation before applying the changes in the terraform code. To skip this confirmation and directly apply the changes use the parameter `-auto-approve`.\n\nThis parameter can also be used with the `destroy` sub-command explained below.\n\n</InlineNotification>\n\n## \"Hello World\" from IBM Cloud\n\nThere is an instance created but it does nothing and you can't do anything with that instance. Make this instance start a Web server with a \"Hello World\" page by adding a short script in the `user_data` parameter. Now, the `ibm_is_instance` resource will look like:\n\n```hcl\nresource \"ibm_is_instance\" \"iac_test_instance\" {\n  name    = \"terraform-test-instance\"\n  image   = \"r006-14140f94-fcc4-11e9-96e7-a72723715315\"\n  profile = \"cx2-2x4\"\n\n  primary_network_interface {\n    name   = \"eth1\"\n    subnet = ibm_is_subnet.iac_test_subnet.id\n  }\n\n  vpc  = ibm_is_vpc.iac_test_vpc.id\n  zone = \"us-south-1\"\n  keys = []\n\n  user_data = <<-EOUD\n              #!/bin/bash\n              echo \"Hello World\" > index.html\n              nohup busybox httpd -f -p 8080 &\n              EOUD\n\n  tags = [ \"iac-terraform-test\" ]\n}\n```\n\nWhen the instance is up and running we need to know the IP address. You could go to the IBM Cloud console and get it from there, however, there is a more effective way to get the IP address with terraform: use the `output` directive.\n\nAdd the following code to your `main.tf` file:\n\n```hcl\noutput \"ip_address\" {\n  value = ibm_is_instance.iac_test_instance.primary_network_interface[0].primary_ipv4_address\n}\n```\n\nThe beauty of Terraform is that you don't have to destroy everything and re-create it for every change, the provider will update all the resources that can be updated and re-create those that don't support an update. In this case, the instance has to be re-created because of the `user_data`, but the VPC and subnet will remain intact, as they were not modified. So, to re-apply the changes just execute `apply` again:\n\n```bash\nterraform apply\n```\n\nWhen terraform complete the task, it prints the IP address of the instance. If you need it again, just execute `terraform output ip_address`.\n\nTo view what you have created on the IBM Cloud console, go to the **Navigation Menu** (<svg class=\"btn-inactive\" focusable=\"false\" preserveAspectRatio=\"xMidYMid meet\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" aria-hidden=\"true\"><path d=\"M2 14.8H18V16H2zM2 11.2H18V12.399999999999999H2zM2 7.6H18V8.799999999999999H2zM2 4H18V5.2H2z\"></path></svg>) >> **VPC Infrastructure**, then select **Network** >> **VPCs**, **Subnets** and **Compute** >> **Virtual server instances** to view all the resources you have created.\n\n![IBM Cloud Resources](./images/vpc-resources.png \"IBM Cloud VPC Resources\")\n\n## Terraform State\n\nYou may have noticed that every time you run `terraform apply` there is a new or updated file named `terraform.tfstate`. This file is the Terraform State file and it store information about the infrastructure created. All the resources and variables are in that file.\n\nThis file is in JSON format and it has a private API, it changes (or may change) every time there is a new Terraform version, so you can read it but it's not recommended to use it to get data from it. Instead, use the `output` variables and the `output` Terraform command.\n\nEvery time you run Terraform it fetch the latest status of every resource in the code and compare it with the state from the `terraform.tfstate` file to determine what changes need to be applied.\n\n<InlineNotification kind=\"warning\">\n\n**Do not delete the terraform.tfstate file**\n\nIf you delete it the next time you want to modify your infrastructure terraform will not know the current state and will complain saying that the resources you want to create already exist.\n\n</InlineNotification>\n\nFor a simple and personal project is fine to have the Terraform state in a local file. Sometimes it's stored in a version control system (i.e. GitHub) however this is not recommended because the state file contain sensitive information that should not be exposed.\n\n<InlineNotification kind=\"warning\">\n\n**Do not commit the state file to GitHub**\n\nDo Not store the `terraform.tfstate` in your GitHub repository, it may contain sensitive information such as passwords or ssh keys. Make sure the `terraform.tfstate` and backup `terraform.tfstate.backup` filenames are in the `.gitignore` file.\n\n</InlineNotification>\n\nFor enterprise projects or if a team is working with the same Terraform code make it's recommended to use a remote state in a shared storage. The most common options to implement remote state is to use a Terraform Backend or use a service such as Terraform Enterprise, Terraform Cloud or IBM Cloud Schematics.\n\nThe setup and use of Terraform backends is explained in the [Setup Terraform Remote State using etcd as backend](/iac/getting-started-terraform/remote-state) section. The use of IBM Cloud Schematics is explained in the next section [IBM Cloud Schematics](/iac/schematics)\n\n## Exposing the service to the world in a secure manner\n\nNow the instance is running and possibly it's serving a web page with Hello World but unfortunately you can't see it. You can't see it because (1) the IP address is private, internal to the IBM Cloud network and (2) there aren't any firewall rules to allow access to the instance. Resolve that by adding a `ibm_is_floating_ip`, a `ibm_is_security_group_rule` and a few `ibm_is_security_group` resources:\n\n```hcl\nresource \"ibm_is_floating_ip\" \"iac_test_floating_ip\" {\n  name   = \"terraform-test-ip\"\n  target = ibm_is_instance.iac_test_instance.primary_network_interface.0.id\n  tags   = [ \"iac-terraform-test\" ]\n}\n\nresource \"ibm_is_security_group\" \"iac_test_security_group\" {\n  name = \"terraform-test-sg-public\"\n  vpc  = ibm_is_vpc.iac_test_vpc.id\n}\n\nresource \"ibm_is_security_group_rule\" \"iac_test_security_group_rule_tcp_http\" {\n  group     = ibm_is_security_group.iac_test_security_group.id\n  direction = \"inbound\"\n  tcp {\n      port_min = 8080\n      port_max = 8080\n  }\n}\n```\n\nThen add the new security group to the `primary_network_interface` of the instance, so it looks like so:\n\n```hcl\nresource \"ibm_is_instance\" \"iac_test_instance\" {\n  ...\n  primary_network_interface {\n    name   = \"eth1\"\n    subnet = ibm_is_subnet.iac_test_subnet.id\n    security_groups = [ ibm_is_security_group.iac_test_security_group.id ]\n  }\n  ...\n}\n```\n\nThe `ibm_is_floating_ip` resource creates a floating IP address that can be used to access the targeted instance from the public network.\n\nThe main input parameters are:\n\n| Input parameter | Description |\n|---|---|\n| `name` | to name the floating IP address |\n| `resource_group` | the ID of the resource group for the floating IP, the default resource group is `default` |\n| `tags` | tags to associate with your floating IPs, they will help you to find them more easily. Separate multiple tags with a comma |\n\nThe most important output parameter is:\n\n| Output parameter | Description |\n|---|---|\n| `address` | the floating IP address |\n\nThe `ibm_is_security_group` resource allows you to create a virtual firewall with rules to control the inbound and outbound traffic. These rules are created with the resource `ibm_is_security_group_rule`.\n\nThe most important input parameters for `ibm_is_security_group` are:\n\n| Input parameter | Description |\n|---|---|\n| `name` | to name the Security Group |\n| `vpc` | the VPC ID for the Security Group. Use the `id` output parameter of the selected `ibm_is_vpc` resource.\n| `resource_group` | the ID of the resource group to create the Security Group there |\n\nAfter it's created you can access all the rules in the security group with the following output parameters:\n\n| Output parameter | Description |\n|---|---|\n| `id` | the Security Group ID |\n| `rules` | a nested block describing the rules of this security group |\n| `rules.direction` | the direction of the traffic either `inbound` or `outbound` |\n| `rules.protocol` | the type of the protocol `all`, `icmp`, `tcp` or `udp` |\n| `rules.port_max` | the inclusive upper bound of TCP/UDP port range |\n| `rules.port_min` | the inclusive lower bound of TCP/UDP port range |\n\nThe `primary_network_interface` of the instance and each `ibm_is_security_group_rule` will reference the new security group using the `id` output parameter.\n\nEach `ibm_is_security_group_rule` defines a traffic rule either for inbound or outbound direction. The most important input parameters are:\n\n| Input parameter | Description |\n|---|---|\n| `group` | the Security Group ID |\n| `direction` | direction of the traffic either `inbound` or `outbound` |\n| `tcp` | a nested block describing the `tcp` protocol of this security group rule |\n| `tcp.port_min` | the inclusive lower bound of TCP port range |\n| `tcp.port_max` | the inclusive upper bound of TCP port range |\n| `udp` | a nested block describing the `udp` protocol of this security group rule |\n| `udp.port_min` | the inclusive lower bound of UDP port range |\n| `udp.port_max` | the inclusive upper bound of UDP port range |\n\nIn addition to the protocols `tcp` and `udp` security group rules recognize `icmp` and `ALL`.\n\nHaving now a public IP address and the port 8080 open to inbound traffic to the instance, we can access the Web service. Change the `ip_address` output variable to:\n\n```hcl\noutput \"ip_address\" {\n  value = ibm_is_floating_ip.iac_test_floating_ip.address\n}\n```\n\nApply the changes again and execute the following line to view the output of the published web page:\n\n```bash\n$ curl \"http://$(terraform output ip_address):8080\"\nHello World\n```\n\n<InlineNotification>\n\n###### Endpoint output variable\n\nNotice the use of the terraform output command to get the value of the variable `ip_address`. In the same way you can create an output variable named, for example `endpoint`, to contain the address for the Web server.\n\nSo, the command to get the web page would be: `curl $(terraform output endpoint)`\n\n</InlineNotification>\n\n## Deploy a configurable server\n\nThe web server is serving on port 8080 but this port has to be set in the security group and the user data configuration. If we decide to change the port in the user data it may be possible to forget to change it in the other security group or vice versa.\n\nTo make this code more DRY and configurable let's define an input variable for the port, like so:\n\n```hcl\nvariable \"port\" {\n  default = 8080\n}\n```\n\nWe can provide the value of this variable in the following ways, where the earlier option takes precedence over the later:\n\n1. With the `-var` command line option of `terraform`\n2. In variable definitions files (`.tfvars`) such as `terraform.tfvars`\n3. As environment variables starting with `TF_VAR_`\n4. Default value in the variable definition\n\nSo, if we want a port other than `8080` just use the parameter `-var`:\n\n```bash\nterraform apply -var=\"port=8081\"\n```\n\nTo use the variable in the code, just replace the `8080` by `var.port` or, in case we want to interpolate the variable in a string, we use `${var.port}`. So the changes in the code look like this:\n\n```hcl\nresource \"ibm_is_instance\" \"iac_test_instance\" {\n  ...\n  user_data = <<-EOUD\n              #!/bin/bash\n              echo \"Hello World\" > index.html\n              nohup busybox httpd -f -p ${var.port} &\n              EOUD\n  ...\n}\n\nresource \"ibm_is_security_group_rule\" \"iac_test_security_group_rule_tcp_http\" {\n  ...\n  tcp {\n      port_min = var.port\n      port_max = var.port\n  }\n}\n```\n\nNow, execute `terraform apply` using the port `8081`. Notice that this will re-create the instance and update the other resources.\n\n```bash\nterraform apply -var=\"port=8081\"\ncurl \"http://$(terraform output ip_address):8081\"\n```\n\nAlternatively, using environment variables would look like this:\n\n```bash\nexport TF_VAR_port=8082\nterraform apply\ncurl \"http://$(terraform output ip_address):${TF_VAR_port}\"\n```\n\n## SSH Access\n\nWe accomplished the initial requirements having the Web service running and printing the \"Hello World\" but what if we want to have SSH access to the instance?\n\nOpen the `main.tf` file to add the resources `ibm_is_ssh_key` and `ibm_is_security_group_rule` to open port `22` to allow SSH access to the instance.\n\n```hcl\nvariable \"public_key_file\"  { default = \"~/.ssh/id_rsa.pub\" }\nlocals {\n  public_key    = \"${file(pathexpand(var.public_key_file))}\"\n}\n\nresource \"ibm_is_security_group_rule\" \"iac_test_security_group_rule_tcp_ssh\" {\n  group = ibm_is_security_group.iac_test_security_group.id\n  direction = \"inbound\"\n  tcp {\n      port_min = 22\n      port_max = 22\n  }\n}\n\nresource \"ibm_is_ssh_key\" \"iac_test_key\" {\n  name       = \"terraform-test-key\"\n  public_key = local.public_key\n  tags       = [ \"iac-terraform-test\" ]\n}\n```\n\nThis SSH Key has to be linked to the instance through the `keys` parameter, so replace the `keys = []` parameter in the instance `iac_test_instance` for:\n\n```hcl\n  keys = [ ibm_is_ssh_key.iac_test_key.id ]\n```\n\nThe resource `ibm_is_ssh_key` creates a SSH key to access a Gen 2 instance. It requires the following input parameters:\n\n| Input parameter | Description |\n|---|---|\n| `name` | the name of the key |\n| `public_key` | the content of the public key |\n| `resource_group` | an optional ID of the resource group for the key |\n| `tags` | optional tags to associate with your key, they will help you to find it more easily. Separate multiple tags with a comma |\n\nInstead of passing to Terraform the content of the public key, this code takes the public key filename in the variable `public_key_file` either as a parameter `-var=\"public_key_file=FILENAME\"` or as an environment variable `TF_VAR_public_key_file=FILENAME` and places the file content into the local variable `public_key` which will be used by the IBM Cloud provider to create a SSH Key resource. If no parameter is given for the public key filename, the default value is set to the well known default filename for RSA public keys: `~/.ssh/id_rsa.pub`.\n\n<InlineNotification>\n\n###### How to create the a key pair?\n\nTo have access to the instances you need a private and public key. You can use the `ssh-keygen` command on Linux or Mac OS X to generate them. Just execute the command `ssh-keygen` and follow the instructions. You can read more about SSH Keys in the [IBM Cloud docs](https://cloud.ibm.com/docs/infrastructure/ssh-keys?topic=ssh-keys-getting-started-tutorial).\n\n</InlineNotification>\n\nAfter applying the changes with `terraform apply` you can access to the instance with SSH either to login or execute remote commands. For example, use the following command to remotely execute `echo 'Hello World'` using the private key `~/.ssh/id_rsa`\n\n```bash\n$ ssh -i ~/.ssh/id_rsa ubuntu@$(terraform output ip_address) \"echo 'Hello World'\"\nHello World\n```\n\n## Final Terraform code\n\nAll the developed code is in a `main.tf` file, however to have a more organized project, you can split the Terraform code in different files. This project is simple and small but as your Terraform code grows it is a common pattern to split the code into directories and Terraform Modules. This is something you'll see in the next section: Getting started with Schematics\n\nThis code is also available in the [Getting Started](https://github.com/IBM/cloud-enterprise-examples/tree/master/iac/01-getting-started) folder of the IaC Pattern Guides GitHub repository.\n\nHere is an example of how to split the terraform code of this \"Hello World\" example into a logical structure based on the types of resources being managed.\n\n### `main.tf`\n\nThis file is the first file that Terraform will access, so include here the provider and the instance.\n\n```hcl path=main.tf\nprovider \"ibm\" {\n  generation         = 2\n  region             = \"us-south\"\n}\n\nresource \"ibm_is_ssh_key\" \"iac_test_key\" {\n  name       = \"terraform-test-key\"\n  public_key = local.public_key\n}\n\nresource \"ibm_is_instance\" \"iac_test_instance\" {\n  name    = \"terraform-test-instance\"\n  image   = \"r006-14140f94-fcc4-11e9-96e7-a72723715315\"\n  profile = \"cx2-2x4\"\n\n  primary_network_interface {\n    name   = \"eth1\"\n    subnet = ibm_is_subnet.iac_test_subnet.id\n    security_groups = [ ibm_is_security_group.iac_test_security_group.id ]\n  }\n\n  vpc  = ibm_is_vpc.iac_test_vpc.id\n  zone = \"us-south-1\"\n  keys = [ ibm_is_ssh_key.iac_test_key.id ]\n\n  user_data = <<-EOUD\n              #!/bin/bash\n              echo \"Hello World\" > index.html\n              nohup busybox httpd -f -p ${var.port} &\n              EOUD\n\n  tags = [ \"iac-terraform-test\" ]\n}\n```\n\n### `variables.tf` and `output.tf`\n\nThese 2 files will have all the input and output variables:\n\n```hcl path=variables.tf\nvariable \"public_key_file\"  { default = \"~/.ssh/id_rsa.pub\" }\nlocals {\n  public_key    = \"${file(pathexpand(var.public_key_file))}\"\n}\n```\n\n```hcl path=output.tf\noutput \"ip_address\" {\n  value = ibm_is_floating_ip.iac_test_floating_ip.address\n}\n\noutput \"entrypoint\" {\n  value = \"http://${ibm_is_floating_ip.iac_test_floating_ip.address}:${var.port}/\"\n}\n```\n\n### `network.tf`\n\nAll the networking resources will be stored in this file:\n\n```hcl path=network.tf\nresource \"ibm_is_vpc\" \"iac_test_vpc\" {\n  name = \"terraform-test-vpc\"\n}\n\nresource \"ibm_is_subnet\" \"iac_test_subnet\" {\n  name            = \"terraform-test-subnet\"\n  vpc             = ibm_is_vpc.iac_test_vpc.id\n  zone            = \"us-south-1\"\n  ipv4_cidr_block = \"10.240.0.0/24\"\n}\n\nresource \"ibm_is_security_group\" \"iac_test_security_group\" {\n  name = \"terraform-test-sg-public\"\n  vpc = ibm_is_vpc.iac_test_vpc.id\n}\n\nresource \"ibm_is_security_group_rule\" \"iac_test_security_group_rule_all_outbound\" {\n  group = ibm_is_security_group.iac_test_security_group.id\n  direction = \"outbound\"\n}\n\nresource \"ibm_is_security_group_rule\" \"iac_test_security_group_rule_tcp_http\" {\n  group = ibm_is_security_group.iac_test_security_group.id\n  direction = \"inbound\"\n  tcp {\n      port_min = var.port\n      port_max = var.port\n  }\n}\n\nresource \"ibm_is_security_group_rule\" \"iac_test_security_group_rule_tcp_ssh\" {\n  group = ibm_is_security_group.iac_test_security_group.id\n  direction = \"inbound\"\n  tcp {\n      port_min = 22\n      port_max = 22\n  }\n}\n\nresource \"ibm_is_floating_ip\" \"iac_test_floating_ip\" {\n  name   = \"terraform-test-ip\"\n  target = ibm_is_instance.iac_test_instance.primary_network_interface.0.id\n}\n```\n\n### Other files\n\nBesides the Terraform files you will need the following files:\n\n- the SSH keys (default are `~/.ssh/id_rsa` and `~/.ssh/id_rsa.pub`).\n- the `terraform_key.json` created to store the IBM Cloud API Key\n- the `terraform.tfstate` and `terraform.tfstate.backup` with the Terraform State\n\nOptionally you can also have a `terraform.tfvars` to set values to the input variables, like so:\n\n```hcl path=terraform.tfvars\nport = 8081\n```\n\nAll these files contain or may contain sensitive information and should not be stored in the GitHub repository. Make sure there is a `.gitignore` file with the following content:\n\n```git path=.gitignore\nterraform_key*.json\n.terraform\n*.tfstate*\nid_rsa*\n*.tfvars*\n```\n\n## Clean up\n\nAfter spending a few minutes admiring your masterpiece and showing it to your friends, you can destroy everything to save money with the command:\n\n```bash\nterraform destroy\n```\n\nAfter the command completes, if you check the `terraform.tfstate` file, it's almost empty, showing no information about the resources.\n\n## Reference\n\n- [IBM Cloud / Terraform](https://cloud.ibm.com/docs/terraform?topic=terraform-getting-started) ([Source](https://github.com/ibm-cloud-docs/terraform))\n- [Setting up the CLI for Terraform](https://cloud.ibm.com/docs/terraform?topic=terraform-setup_cli)\n- [IBM Cloud provider for Terraform](https://cloud.ibm.com/docs/terraform?topic=terraform-quick-links)\n- [`provider` block configuration](https://cloud.ibm.com/docs/terraform?topic=terraform-provider-reference#required-parameters)\n- [VPC Infrastructure resources (Gen 2)](https://cloud.ibm.com/docs/terraform?topic=terraform-vpc-gen2-resources)\n- [User data](https://cloud.ibm.com/docs/vpc-on-classic-vsi?topic=vpc-on-classic-vsi-user-data)\n- [Terraform IBM Cloud provider](https://github.com/IBM-Cloud/terraform-provider-ibm)\n\n<!--\n- Terraform IBM Cloud provider - [website](https://github.com/IBM-Cloud/terraform-provider-ibm/blob/master/website/docs/index.html.markdown) (possible old source of *IBM Cloud / Terraform*)\n- Terraform IBM Cloud provider - [examples](https://github.com/IBM-Cloud/terraform-provider-ibm/tree/master/examples)\n- Terraform IBM Cloud provider - [docs](https://ibm-cloud.github.io/tf-ibm-docs/) (old version of *IBM Cloud / Terraform*)\n- IBM Cloud - Create a [Virtual Private Cloud](https://cloud.ibm.com/vpc/overview) (VPC)\n- IBM Cloud - Docs for [Virtual Private Cloud](https://cloud.ibm.com/docs/vpc?topic=vpc-getting-started) (VPC)\n-->\n","type":"Mdx","contentDigest":"fefb74afad91087dc923d4b1cd36ea73","counter":729,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Getting Started with Terraform","description":"Instructions to setup your environment to use Terraform for IBM Cloud","keywords":"terraform,ibm cloud,setup,provider"},"exports":{},"rawBody":"---\ntitle: Getting Started with Terraform\ndescription: Instructions to setup your environment to use Terraform for IBM Cloud\nkeywords: 'terraform,ibm cloud,setup,provider'\n---\n\n<!--\n\nThe pattern to document the resources is like follow:\n- Introduce the resource with an example\n- List all or the most important input parameters\n- If will be used, list the most important output parameters\n- Provide instructions to get the value of the input parameters, either using `ibmcloud`, API or the Web console.\n- If needed, instructions to execute the code either with Terraform or Schematics\n\n-->\n\n<PageDescription>\n\nLearn the basics of Infrastructure as Code with Terraform on IBM Cloud\n\n</PageDescription>\n\nAfter you have configured and verified Terraform and the IBM Cloud provider, this section will go through a step-by-step example of creating a resource on IBM Cloud using the provider. It covers how to create a virtual server from scratch. To do this, there is example terraform code to create a vpc and subnet, add a virtual server to the vpc, configure an access list and expose the virtual server on the Internet, and then access it over ssh. If you are an experienced Terraform user, you may skim through this section and simply note the resource types and parameters used in each step.\n\n<AnchorLinks small>\n  <AnchorLink>Deploy a single instance</AnchorLink>\n  <AnchorLink>“Hello World” from IBM Cloud</AnchorLink>\n  <AnchorLink>Terraform State</AnchorLink>\n  <AnchorLink>Exposing the service to the world in a secure manner</AnchorLink>\n  <AnchorLink>Deploy a configurable server</AnchorLink>\n  <AnchorLink>SSH Access</AnchorLink>\n  <AnchorLink>Final Terraform code</AnchorLink>\n  <AnchorLink>Clean up</AnchorLink>\n</AnchorLinks>\n\n## Deploy a single instance\n\nThe first step to use Terraform with IBM Cloud is to configure the provider. Lets start creating a directory to store the \"Hello World\" project.\n\n```bash\nmkdir hello_world_terraform_ibm\ncd hello_world_terraform_ibm\n```\n\nRemember to export in the terminal or console the variable `IC_API_KEY` with the IBM Cloud API key as shown in the <GatsbyLink to=\"/iac/setup-environment#configure-access-to-ibm-cloud\">Environment Setup</GatsbyLink>.\n\nThe Terraform code can be done with JSON format or using **HashiCorp Configuration Language** (HCL). During this pattern guide we'll use only HCL and we will call it HCL or Terraform Code.\n\nThe Terraform code can be done with JSON format or using **HashiCorp Configuration Language** (HCL). During this pattern guide we'll use only HCL and we will call it HCL or Terraform Code.\n\nCreate the file `main.tf` with the `provider` block.\n\n```hcl\nprovider \"ibm\" {\n  generation         = 2\n  region             = \"us-south\"\n}\n```\n\nWe will be working with VPC Infrastructure Gen 2, the provider accepts the following common input parameters:\n\n| Input parameter | Description |\n|---|---|\n| `generation` | the generation of IBM Cloud VPC Infrastructure, in this case it'll be `2` |\n| `region` | the region where you want to create the VPC resources, examples: `us-south` or `us-east` |\n| `ibmcloud_api_key` | the IBM Cloud API key. However we recommend to enter this parameter with the environment variable `IC_API_KEY` |\n\nTo find all the available regions with IBM Cloud CLI you can use the `is` sub-command (for more information on installing this plugin refer to [Setup Environment](/iac/setup-environment)):\n\n```bash\nibmcloud is regions\n```\n\nNow execute the terraform sub-commands `init` and `plan`:\n\n```bash\nterraform init\nterraform plan\n```\n\nThe `init` sub-command downloads all the terraform components needed to execute or apply the terraform code, in this simple example it does not need to download any, the only component we need is the IBM Cloud provider and it is already installed. You'll see there is a new `.terraform` directory, this is where terraform will store all the required components for your terraform project.\n\nThe output of `plan` shows the resources that will be created, updated and deleted, in this case terraform won't do anything.\n\nTo create a VM or instance we use the resource `ibm_is_instance` but in order to have an instance you first need the networking resources to build the instance on top of it.\n\nOn IBM Cloud there is no VPC created by default, you will need to create your VPC using the `ibm_is_vpc` resource. Then we'll need a subnet on that VPC, the subnets are created with the resource `ibm_is_subnet`.\n\n<InlineNotification>\n\n###### Resources naming convention\n\nIn case you haven't noticed yet, the IBM Cloud resources begin with `ibm_`, the `is_` stands for Internet Service.\n\n</InlineNotification>\n\nThe Terraform code to create the VPC and the Subnet is as follows:\n\n```hcl\nresource \"ibm_is_vpc\" \"iac_test_vpc\" {\n  name = \"terraform-test-vpc\"\n  tags = [ \"iac-terraform-test\" ]\n}\n\nresource \"ibm_is_subnet\" \"iac_test_subnet\" {\n  name            = \"terraform-test-subnet\"\n  vpc             = ibm_is_vpc.iac_test_vpc.id\n  zone            = \"us-south-1\"\n  tags = [ \"iac-terraform-test\" ]\n}\n```\n\nThe most important input parameters to create the VPC and the Subnet are listed below.\n\nFor the `ibm_is_vpc` resource:\n\n| Input parameter | Description |\n|---|---|\n| `name` | to name the VPC |\n| `resource_group` | the ID of the resource group for the VPC, the default resource group is `default` |\n| `tags` | tags to associate with your VPC, they will help you to find the VPC more easily. Separate multiple tags with a comma |\n\nFor the `ibm_is_subnet` resource:\n\n| Input parameter | Description |\n|---|---|\n| `name` | to name the Subnet |\n| `vpc` | the ID of the VPC, use the resource name with `.id` |\n| `zone` | the subnet zone name |\n| `resource_group` | the ID of the resource group for the Subnet |\n| `tags` | tags to associate with your Subnet, they will help you to find it more easily. Separate multiple tags with a comma |\n\nThe IBM Cloud virtual server instance is created with the resource `ibm_is_instance`, a basic terraform code to create an instance would be like so:\n\n```hcl\nresource \"ibm_is_instance\" \"iac_test_instance\" {\n  name    = \"terraform-test-instance\"\n  image   = \"r006-14140f94-fcc4-11e9-96e7-a72723715315\"\n  profile = \"cx2-2x4\"\n\n  primary_network_interface {\n    name   = \"eth1\"\n    subnet = ibm_is_subnet.iac_test_subnet.id\n  }\n\n  vpc  = ibm_is_vpc.iac_test_vpc.id\n  zone = \"us-south-1\"\n  keys = []\n\n  tags = [ \"iac-terraform-test\" ]\n}\n```\n\nSome of the most important input parameters are:\n\n| Input parameter | Description |\n|---|---|\n| `name` | to name the new instance |\n| `image` | the ID of the virtual server image to use for the instance |\n| `profile` | name of the profile to use for your instance |\n| `vpc`  | the ID of the VPC where you want to create the instance |\n| `zone` | name of the VPC zone to create the instance |\n| `keys` | a comma separated list of SSH keys that you want to add to your instance |\n| `primary_network_interface.subnet` | the ID of the subnet. Only one primary network interface can be specified for an instance |\n| `tags` | a list of tags to add to your instance. Tags can help you find your instance |\n| `user_data` | user data to transfer to the instance |\n\n<InlineNotification>\n\n###### VPC Networking and Virtual Servers\n\nCheck the documentation to know more about [Networking for VPC](https://cloud.ibm.com/docs/vpc?topic=vpc-about-networking-for-vpc) and [Virtual Servers](https://cloud.ibm.com/docs/vpc?topic=vpc-about-advanced-virtual-servers).\n\n</InlineNotification>\n\nTo list all the available images and profiles we will use `ibmcloud is`, specify the **Gen 2** platform before running the command:\n\n```bash\nibmcloud is target --gen 2        # this is a one time execution only, unless you swap to gen 1\nibmcloud is instance-profiles\nibmcloud is images\n```\n\nThat's a lot of images, to narrow our search let's filter the output to get the available images for `Ubuntu 18.4` (`LTS Bionic`) and for `amd64` architecture using regular *nix commands or with `jq`, if you have `jq` installed ([how to install jq](https://github.com/stedolan/jq/wiki/Installation)):\n\n```bash\nibmcloud is images | grep available | grep ubuntu-18 | grep amd64 | cut -f1 -d\" \"\n\nibmcloud is images --json | jq -r '.[] | select(.status==\"available\" and .operating_system.name==\"ubuntu-18-04-amd64\").id'\n```\n\nRepeating for the instance profiles searching just the `amd64` architecture with the minimum CPU and Memory to get the lowest cost.\n\n```bash\nibmcloud is instance-profiles | grep amd64 | sort -k4 -k5 -n | head -1 | cut -f1 -d\" \"\n\nibmcloud is instance-profiles --json | jq -r 'map(select(.vcpu_architecture.value==\"amd64\")) | sort_by(.memory.value)[0].name'\n```\n\nNotice that in the terraform code there are no `keys` this is because the instance will be used only to start a web service, and we are not going to ssh to the instance at this time.\n\nYou can use `user_data` to run common configuration tasks when your instance starts. For example, you can specify cloud-init directives or shell scripts for Linux images. You will see an example of using the `user_data` parameter in the next session.\n\nAdd to the `main.tf` file the terraform code for the vpc, subnet and instance. Now, if you execute `terraform plan` it shows the resources that will be created, updated and deleted. In this case terraform will create 3 resources: the VPC, the subnet and the instance.\n\nEverything is ready now to get that instance in the cloud, just execute the terraform `apply` sub-command and wait about 10 to 60 seconds.\n\n```bash\nterraform apply\n```\n\n<InlineNotification>\n\n###### Can I make it non-interactive?\n\nTerraform will ask for confirmation before applying the changes in the terraform code. To skip this confirmation and directly apply the changes use the parameter `-auto-approve`.\n\nThis parameter can also be used with the `destroy` sub-command explained below.\n\n</InlineNotification>\n\n## \"Hello World\" from IBM Cloud\n\nThere is an instance created but it does nothing and you can't do anything with that instance. Make this instance start a Web server with a \"Hello World\" page by adding a short script in the `user_data` parameter. Now, the `ibm_is_instance` resource will look like:\n\n```hcl\nresource \"ibm_is_instance\" \"iac_test_instance\" {\n  name    = \"terraform-test-instance\"\n  image   = \"r006-14140f94-fcc4-11e9-96e7-a72723715315\"\n  profile = \"cx2-2x4\"\n\n  primary_network_interface {\n    name   = \"eth1\"\n    subnet = ibm_is_subnet.iac_test_subnet.id\n  }\n\n  vpc  = ibm_is_vpc.iac_test_vpc.id\n  zone = \"us-south-1\"\n  keys = []\n\n  user_data = <<-EOUD\n              #!/bin/bash\n              echo \"Hello World\" > index.html\n              nohup busybox httpd -f -p 8080 &\n              EOUD\n\n  tags = [ \"iac-terraform-test\" ]\n}\n```\n\nWhen the instance is up and running we need to know the IP address. You could go to the IBM Cloud console and get it from there, however, there is a more effective way to get the IP address with terraform: use the `output` directive.\n\nAdd the following code to your `main.tf` file:\n\n```hcl\noutput \"ip_address\" {\n  value = ibm_is_instance.iac_test_instance.primary_network_interface[0].primary_ipv4_address\n}\n```\n\nThe beauty of Terraform is that you don't have to destroy everything and re-create it for every change, the provider will update all the resources that can be updated and re-create those that don't support an update. In this case, the instance has to be re-created because of the `user_data`, but the VPC and subnet will remain intact, as they were not modified. So, to re-apply the changes just execute `apply` again:\n\n```bash\nterraform apply\n```\n\nWhen terraform complete the task, it prints the IP address of the instance. If you need it again, just execute `terraform output ip_address`.\n\nTo view what you have created on the IBM Cloud console, go to the **Navigation Menu** (<svg class=\"btn-inactive\" focusable=\"false\" preserveAspectRatio=\"xMidYMid meet\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" aria-hidden=\"true\"><path d=\"M2 14.8H18V16H2zM2 11.2H18V12.399999999999999H2zM2 7.6H18V8.799999999999999H2zM2 4H18V5.2H2z\"></path></svg>) >> **VPC Infrastructure**, then select **Network** >> **VPCs**, **Subnets** and **Compute** >> **Virtual server instances** to view all the resources you have created.\n\n![IBM Cloud Resources](./images/vpc-resources.png \"IBM Cloud VPC Resources\")\n\n## Terraform State\n\nYou may have noticed that every time you run `terraform apply` there is a new or updated file named `terraform.tfstate`. This file is the Terraform State file and it store information about the infrastructure created. All the resources and variables are in that file.\n\nThis file is in JSON format and it has a private API, it changes (or may change) every time there is a new Terraform version, so you can read it but it's not recommended to use it to get data from it. Instead, use the `output` variables and the `output` Terraform command.\n\nEvery time you run Terraform it fetch the latest status of every resource in the code and compare it with the state from the `terraform.tfstate` file to determine what changes need to be applied.\n\n<InlineNotification kind=\"warning\">\n\n**Do not delete the terraform.tfstate file**\n\nIf you delete it the next time you want to modify your infrastructure terraform will not know the current state and will complain saying that the resources you want to create already exist.\n\n</InlineNotification>\n\nFor a simple and personal project is fine to have the Terraform state in a local file. Sometimes it's stored in a version control system (i.e. GitHub) however this is not recommended because the state file contain sensitive information that should not be exposed.\n\n<InlineNotification kind=\"warning\">\n\n**Do not commit the state file to GitHub**\n\nDo Not store the `terraform.tfstate` in your GitHub repository, it may contain sensitive information such as passwords or ssh keys. Make sure the `terraform.tfstate` and backup `terraform.tfstate.backup` filenames are in the `.gitignore` file.\n\n</InlineNotification>\n\nFor enterprise projects or if a team is working with the same Terraform code make it's recommended to use a remote state in a shared storage. The most common options to implement remote state is to use a Terraform Backend or use a service such as Terraform Enterprise, Terraform Cloud or IBM Cloud Schematics.\n\nThe setup and use of Terraform backends is explained in the [Setup Terraform Remote State using etcd as backend](/iac/getting-started-terraform/remote-state) section. The use of IBM Cloud Schematics is explained in the next section [IBM Cloud Schematics](/iac/schematics)\n\n## Exposing the service to the world in a secure manner\n\nNow the instance is running and possibly it's serving a web page with Hello World but unfortunately you can't see it. You can't see it because (1) the IP address is private, internal to the IBM Cloud network and (2) there aren't any firewall rules to allow access to the instance. Resolve that by adding a `ibm_is_floating_ip`, a `ibm_is_security_group_rule` and a few `ibm_is_security_group` resources:\n\n```hcl\nresource \"ibm_is_floating_ip\" \"iac_test_floating_ip\" {\n  name   = \"terraform-test-ip\"\n  target = ibm_is_instance.iac_test_instance.primary_network_interface.0.id\n  tags   = [ \"iac-terraform-test\" ]\n}\n\nresource \"ibm_is_security_group\" \"iac_test_security_group\" {\n  name = \"terraform-test-sg-public\"\n  vpc  = ibm_is_vpc.iac_test_vpc.id\n}\n\nresource \"ibm_is_security_group_rule\" \"iac_test_security_group_rule_tcp_http\" {\n  group     = ibm_is_security_group.iac_test_security_group.id\n  direction = \"inbound\"\n  tcp {\n      port_min = 8080\n      port_max = 8080\n  }\n}\n```\n\nThen add the new security group to the `primary_network_interface` of the instance, so it looks like so:\n\n```hcl\nresource \"ibm_is_instance\" \"iac_test_instance\" {\n  ...\n  primary_network_interface {\n    name   = \"eth1\"\n    subnet = ibm_is_subnet.iac_test_subnet.id\n    security_groups = [ ibm_is_security_group.iac_test_security_group.id ]\n  }\n  ...\n}\n```\n\nThe `ibm_is_floating_ip` resource creates a floating IP address that can be used to access the targeted instance from the public network.\n\nThe main input parameters are:\n\n| Input parameter | Description |\n|---|---|\n| `name` | to name the floating IP address |\n| `resource_group` | the ID of the resource group for the floating IP, the default resource group is `default` |\n| `tags` | tags to associate with your floating IPs, they will help you to find them more easily. Separate multiple tags with a comma |\n\nThe most important output parameter is:\n\n| Output parameter | Description |\n|---|---|\n| `address` | the floating IP address |\n\nThe `ibm_is_security_group` resource allows you to create a virtual firewall with rules to control the inbound and outbound traffic. These rules are created with the resource `ibm_is_security_group_rule`.\n\nThe most important input parameters for `ibm_is_security_group` are:\n\n| Input parameter | Description |\n|---|---|\n| `name` | to name the Security Group |\n| `vpc` | the VPC ID for the Security Group. Use the `id` output parameter of the selected `ibm_is_vpc` resource.\n| `resource_group` | the ID of the resource group to create the Security Group there |\n\nAfter it's created you can access all the rules in the security group with the following output parameters:\n\n| Output parameter | Description |\n|---|---|\n| `id` | the Security Group ID |\n| `rules` | a nested block describing the rules of this security group |\n| `rules.direction` | the direction of the traffic either `inbound` or `outbound` |\n| `rules.protocol` | the type of the protocol `all`, `icmp`, `tcp` or `udp` |\n| `rules.port_max` | the inclusive upper bound of TCP/UDP port range |\n| `rules.port_min` | the inclusive lower bound of TCP/UDP port range |\n\nThe `primary_network_interface` of the instance and each `ibm_is_security_group_rule` will reference the new security group using the `id` output parameter.\n\nEach `ibm_is_security_group_rule` defines a traffic rule either for inbound or outbound direction. The most important input parameters are:\n\n| Input parameter | Description |\n|---|---|\n| `group` | the Security Group ID |\n| `direction` | direction of the traffic either `inbound` or `outbound` |\n| `tcp` | a nested block describing the `tcp` protocol of this security group rule |\n| `tcp.port_min` | the inclusive lower bound of TCP port range |\n| `tcp.port_max` | the inclusive upper bound of TCP port range |\n| `udp` | a nested block describing the `udp` protocol of this security group rule |\n| `udp.port_min` | the inclusive lower bound of UDP port range |\n| `udp.port_max` | the inclusive upper bound of UDP port range |\n\nIn addition to the protocols `tcp` and `udp` security group rules recognize `icmp` and `ALL`.\n\nHaving now a public IP address and the port 8080 open to inbound traffic to the instance, we can access the Web service. Change the `ip_address` output variable to:\n\n```hcl\noutput \"ip_address\" {\n  value = ibm_is_floating_ip.iac_test_floating_ip.address\n}\n```\n\nApply the changes again and execute the following line to view the output of the published web page:\n\n```bash\n$ curl \"http://$(terraform output ip_address):8080\"\nHello World\n```\n\n<InlineNotification>\n\n###### Endpoint output variable\n\nNotice the use of the terraform output command to get the value of the variable `ip_address`. In the same way you can create an output variable named, for example `endpoint`, to contain the address for the Web server.\n\nSo, the command to get the web page would be: `curl $(terraform output endpoint)`\n\n</InlineNotification>\n\n## Deploy a configurable server\n\nThe web server is serving on port 8080 but this port has to be set in the security group and the user data configuration. If we decide to change the port in the user data it may be possible to forget to change it in the other security group or vice versa.\n\nTo make this code more DRY and configurable let's define an input variable for the port, like so:\n\n```hcl\nvariable \"port\" {\n  default = 8080\n}\n```\n\nWe can provide the value of this variable in the following ways, where the earlier option takes precedence over the later:\n\n1. With the `-var` command line option of `terraform`\n2. In variable definitions files (`.tfvars`) such as `terraform.tfvars`\n3. As environment variables starting with `TF_VAR_`\n4. Default value in the variable definition\n\nSo, if we want a port other than `8080` just use the parameter `-var`:\n\n```bash\nterraform apply -var=\"port=8081\"\n```\n\nTo use the variable in the code, just replace the `8080` by `var.port` or, in case we want to interpolate the variable in a string, we use `${var.port}`. So the changes in the code look like this:\n\n```hcl\nresource \"ibm_is_instance\" \"iac_test_instance\" {\n  ...\n  user_data = <<-EOUD\n              #!/bin/bash\n              echo \"Hello World\" > index.html\n              nohup busybox httpd -f -p ${var.port} &\n              EOUD\n  ...\n}\n\nresource \"ibm_is_security_group_rule\" \"iac_test_security_group_rule_tcp_http\" {\n  ...\n  tcp {\n      port_min = var.port\n      port_max = var.port\n  }\n}\n```\n\nNow, execute `terraform apply` using the port `8081`. Notice that this will re-create the instance and update the other resources.\n\n```bash\nterraform apply -var=\"port=8081\"\ncurl \"http://$(terraform output ip_address):8081\"\n```\n\nAlternatively, using environment variables would look like this:\n\n```bash\nexport TF_VAR_port=8082\nterraform apply\ncurl \"http://$(terraform output ip_address):${TF_VAR_port}\"\n```\n\n## SSH Access\n\nWe accomplished the initial requirements having the Web service running and printing the \"Hello World\" but what if we want to have SSH access to the instance?\n\nOpen the `main.tf` file to add the resources `ibm_is_ssh_key` and `ibm_is_security_group_rule` to open port `22` to allow SSH access to the instance.\n\n```hcl\nvariable \"public_key_file\"  { default = \"~/.ssh/id_rsa.pub\" }\nlocals {\n  public_key    = \"${file(pathexpand(var.public_key_file))}\"\n}\n\nresource \"ibm_is_security_group_rule\" \"iac_test_security_group_rule_tcp_ssh\" {\n  group = ibm_is_security_group.iac_test_security_group.id\n  direction = \"inbound\"\n  tcp {\n      port_min = 22\n      port_max = 22\n  }\n}\n\nresource \"ibm_is_ssh_key\" \"iac_test_key\" {\n  name       = \"terraform-test-key\"\n  public_key = local.public_key\n  tags       = [ \"iac-terraform-test\" ]\n}\n```\n\nThis SSH Key has to be linked to the instance through the `keys` parameter, so replace the `keys = []` parameter in the instance `iac_test_instance` for:\n\n```hcl\n  keys = [ ibm_is_ssh_key.iac_test_key.id ]\n```\n\nThe resource `ibm_is_ssh_key` creates a SSH key to access a Gen 2 instance. It requires the following input parameters:\n\n| Input parameter | Description |\n|---|---|\n| `name` | the name of the key |\n| `public_key` | the content of the public key |\n| `resource_group` | an optional ID of the resource group for the key |\n| `tags` | optional tags to associate with your key, they will help you to find it more easily. Separate multiple tags with a comma |\n\nInstead of passing to Terraform the content of the public key, this code takes the public key filename in the variable `public_key_file` either as a parameter `-var=\"public_key_file=FILENAME\"` or as an environment variable `TF_VAR_public_key_file=FILENAME` and places the file content into the local variable `public_key` which will be used by the IBM Cloud provider to create a SSH Key resource. If no parameter is given for the public key filename, the default value is set to the well known default filename for RSA public keys: `~/.ssh/id_rsa.pub`.\n\n<InlineNotification>\n\n###### How to create the a key pair?\n\nTo have access to the instances you need a private and public key. You can use the `ssh-keygen` command on Linux or Mac OS X to generate them. Just execute the command `ssh-keygen` and follow the instructions. You can read more about SSH Keys in the [IBM Cloud docs](https://cloud.ibm.com/docs/infrastructure/ssh-keys?topic=ssh-keys-getting-started-tutorial).\n\n</InlineNotification>\n\nAfter applying the changes with `terraform apply` you can access to the instance with SSH either to login or execute remote commands. For example, use the following command to remotely execute `echo 'Hello World'` using the private key `~/.ssh/id_rsa`\n\n```bash\n$ ssh -i ~/.ssh/id_rsa ubuntu@$(terraform output ip_address) \"echo 'Hello World'\"\nHello World\n```\n\n## Final Terraform code\n\nAll the developed code is in a `main.tf` file, however to have a more organized project, you can split the Terraform code in different files. This project is simple and small but as your Terraform code grows it is a common pattern to split the code into directories and Terraform Modules. This is something you'll see in the next section: Getting started with Schematics\n\nThis code is also available in the [Getting Started](https://github.com/IBM/cloud-enterprise-examples/tree/master/iac/01-getting-started) folder of the IaC Pattern Guides GitHub repository.\n\nHere is an example of how to split the terraform code of this \"Hello World\" example into a logical structure based on the types of resources being managed.\n\n### `main.tf`\n\nThis file is the first file that Terraform will access, so include here the provider and the instance.\n\n```hcl path=main.tf\nprovider \"ibm\" {\n  generation         = 2\n  region             = \"us-south\"\n}\n\nresource \"ibm_is_ssh_key\" \"iac_test_key\" {\n  name       = \"terraform-test-key\"\n  public_key = local.public_key\n}\n\nresource \"ibm_is_instance\" \"iac_test_instance\" {\n  name    = \"terraform-test-instance\"\n  image   = \"r006-14140f94-fcc4-11e9-96e7-a72723715315\"\n  profile = \"cx2-2x4\"\n\n  primary_network_interface {\n    name   = \"eth1\"\n    subnet = ibm_is_subnet.iac_test_subnet.id\n    security_groups = [ ibm_is_security_group.iac_test_security_group.id ]\n  }\n\n  vpc  = ibm_is_vpc.iac_test_vpc.id\n  zone = \"us-south-1\"\n  keys = [ ibm_is_ssh_key.iac_test_key.id ]\n\n  user_data = <<-EOUD\n              #!/bin/bash\n              echo \"Hello World\" > index.html\n              nohup busybox httpd -f -p ${var.port} &\n              EOUD\n\n  tags = [ \"iac-terraform-test\" ]\n}\n```\n\n### `variables.tf` and `output.tf`\n\nThese 2 files will have all the input and output variables:\n\n```hcl path=variables.tf\nvariable \"public_key_file\"  { default = \"~/.ssh/id_rsa.pub\" }\nlocals {\n  public_key    = \"${file(pathexpand(var.public_key_file))}\"\n}\n```\n\n```hcl path=output.tf\noutput \"ip_address\" {\n  value = ibm_is_floating_ip.iac_test_floating_ip.address\n}\n\noutput \"entrypoint\" {\n  value = \"http://${ibm_is_floating_ip.iac_test_floating_ip.address}:${var.port}/\"\n}\n```\n\n### `network.tf`\n\nAll the networking resources will be stored in this file:\n\n```hcl path=network.tf\nresource \"ibm_is_vpc\" \"iac_test_vpc\" {\n  name = \"terraform-test-vpc\"\n}\n\nresource \"ibm_is_subnet\" \"iac_test_subnet\" {\n  name            = \"terraform-test-subnet\"\n  vpc             = ibm_is_vpc.iac_test_vpc.id\n  zone            = \"us-south-1\"\n  ipv4_cidr_block = \"10.240.0.0/24\"\n}\n\nresource \"ibm_is_security_group\" \"iac_test_security_group\" {\n  name = \"terraform-test-sg-public\"\n  vpc = ibm_is_vpc.iac_test_vpc.id\n}\n\nresource \"ibm_is_security_group_rule\" \"iac_test_security_group_rule_all_outbound\" {\n  group = ibm_is_security_group.iac_test_security_group.id\n  direction = \"outbound\"\n}\n\nresource \"ibm_is_security_group_rule\" \"iac_test_security_group_rule_tcp_http\" {\n  group = ibm_is_security_group.iac_test_security_group.id\n  direction = \"inbound\"\n  tcp {\n      port_min = var.port\n      port_max = var.port\n  }\n}\n\nresource \"ibm_is_security_group_rule\" \"iac_test_security_group_rule_tcp_ssh\" {\n  group = ibm_is_security_group.iac_test_security_group.id\n  direction = \"inbound\"\n  tcp {\n      port_min = 22\n      port_max = 22\n  }\n}\n\nresource \"ibm_is_floating_ip\" \"iac_test_floating_ip\" {\n  name   = \"terraform-test-ip\"\n  target = ibm_is_instance.iac_test_instance.primary_network_interface.0.id\n}\n```\n\n### Other files\n\nBesides the Terraform files you will need the following files:\n\n- the SSH keys (default are `~/.ssh/id_rsa` and `~/.ssh/id_rsa.pub`).\n- the `terraform_key.json` created to store the IBM Cloud API Key\n- the `terraform.tfstate` and `terraform.tfstate.backup` with the Terraform State\n\nOptionally you can also have a `terraform.tfvars` to set values to the input variables, like so:\n\n```hcl path=terraform.tfvars\nport = 8081\n```\n\nAll these files contain or may contain sensitive information and should not be stored in the GitHub repository. Make sure there is a `.gitignore` file with the following content:\n\n```git path=.gitignore\nterraform_key*.json\n.terraform\n*.tfstate*\nid_rsa*\n*.tfvars*\n```\n\n## Clean up\n\nAfter spending a few minutes admiring your masterpiece and showing it to your friends, you can destroy everything to save money with the command:\n\n```bash\nterraform destroy\n```\n\nAfter the command completes, if you check the `terraform.tfstate` file, it's almost empty, showing no information about the resources.\n\n## Reference\n\n- [IBM Cloud / Terraform](https://cloud.ibm.com/docs/terraform?topic=terraform-getting-started) ([Source](https://github.com/ibm-cloud-docs/terraform))\n- [Setting up the CLI for Terraform](https://cloud.ibm.com/docs/terraform?topic=terraform-setup_cli)\n- [IBM Cloud provider for Terraform](https://cloud.ibm.com/docs/terraform?topic=terraform-quick-links)\n- [`provider` block configuration](https://cloud.ibm.com/docs/terraform?topic=terraform-provider-reference#required-parameters)\n- [VPC Infrastructure resources (Gen 2)](https://cloud.ibm.com/docs/terraform?topic=terraform-vpc-gen2-resources)\n- [User data](https://cloud.ibm.com/docs/vpc-on-classic-vsi?topic=vpc-on-classic-vsi-user-data)\n- [Terraform IBM Cloud provider](https://github.com/IBM-Cloud/terraform-provider-ibm)\n\n<!--\n- Terraform IBM Cloud provider - [website](https://github.com/IBM-Cloud/terraform-provider-ibm/blob/master/website/docs/index.html.markdown) (possible old source of *IBM Cloud / Terraform*)\n- Terraform IBM Cloud provider - [examples](https://github.com/IBM-Cloud/terraform-provider-ibm/tree/master/examples)\n- Terraform IBM Cloud provider - [docs](https://ibm-cloud.github.io/tf-ibm-docs/) (old version of *IBM Cloud / Terraform*)\n- IBM Cloud - Create a [Virtual Private Cloud](https://cloud.ibm.com/vpc/overview) (VPC)\n- IBM Cloud - Docs for [Virtual Private Cloud](https://cloud.ibm.com/docs/vpc?topic=vpc-getting-started) (VPC)\n-->\n","fileAbsolutePath":"/Users/timro/Public/ISV/cloud-enterprise-examples/website/src/pages/iac/getting-started-terraform/index.mdx"}}}}